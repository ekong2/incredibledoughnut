---
title: "Modern Data Mining - HW 3"
author:
- Aditi Jayashankar
- Eddie Kong
- Sahana Vijaya Prasad
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height=4, fig.width=6, warning = F)
if(!require('pacman')) {
  install.packages('pacman')
}
pacman::p_load(glmnet,bestglm, pROC, leaps, car, tidyverse, mapproj, caret, xtable)
# constants for homework assignments
hw_num <- 3
hw_due_date <- "22 October, 2017"
```



## Overview / Instructions

This is homework #`r paste(hw_num)` of STAT 471/571/701. It will be **due on `r paste(hw_due_date)` by 11:59 PM** on Canvas. You can directly edit this file to add your answers. Submit the Rmd file, a PDF or word or HTML version with only 1 submission per HW team.

**Note:** To minimize your work and errors, we provide this Rmd file to guide you in the process of building your final report. To that end, we've included code to load the necessary data files. Make sure that the following files are in the same folder as this R Markdown file:

* `FRAMINGHAM.dat`
* `Bills.subset.csv`
* `Bills.subset.test.csv`

The data should load properly if you are working in Rstudio, *without needing to change your working directory*.

Solutions will be posted. Make sure to compare your answers to and understand the solutions.

## Problem 0

Review the code and concepts covered during lecture, in particular, logistic regression and classification. 

## Problem 1
We will continue to use the Framingham Data (`Framingham.dat`) so that you are already familiar with the data and the variables. All the results are obtained through training data.

To keep our answers consistent, use a subset of the data, and exclude anyone with a missing entry. For your convenience, we've loaded it here together with a brief summary about the data.

```{r data preparation, include = F}
# Notice that we hide the code and the results here
# Using `include=F` in the chunk declaration
hd_data <- read.csv("Framingham.dat")
str(hd_data) 

### Renames, setting the variables with correct natures...
names(hd_data)[1] <- "HD"
hd_data$HD <- as.factor(hd_data$HD)
hd_data$SEX <- as.factor(hd_data$SEX)
str(hd_data)
#tail(hd_data, 1)    # The last row is for prediction
hd_data.new <- hd_data[1407,] # The female whose HD will be predicted.
hd_data <- hd_data[-1407,]  # take out the last row 
hd_data.f <- na.omit(hd_data)
```

We note that this dataset contains 311 people diagnosed with heart disease and 1095 without heart disease.
```{r table heart disease, echo = F, comment = " "}
# we use echo = F to avoid showing this R code
table(hd_data$HD) # HD: 311 of "0" and 1095 "1" 
```

After a quick cleaning up here is a summary about the data:
```{r data summary, comment="     "}
# using the comment="     ", we get rid of the ## in the output.
summary(hd_data.f)
```

### Part 1A
Goal: Identify important risk factors for `Heart.Disease.` through logistic regression. 
Start a fit with just one factor, `SBP`, and call it `fit1`. Let us add one variable to this at a time from among the rest of the variables. 
```{r, results='hide'}
fit1 <- glm(HD~SBP, hd_data.f, family=binomial)
summary(fit1)
fit1.1 <- glm(HD~SBP + AGE, hd_data.f, family=binomial)
summary(fit1.1)
fit1.2 <- glm(HD~SBP + SEX, hd_data.f, family=binomial)
summary(fit1.2)
fit1.3 <- glm(HD~SBP + DBP, hd_data.f, family=binomial)
summary(fit1.3)
fit1.4 <- glm(HD~SBP + CHOL, hd_data.f, family=binomial)
summary(fit1.4)
fit1.5 <- glm(HD~SBP + DBP, hd_data.f, family=binomial)
summary(fit1.5)
fit1.6 <- glm(HD~SBP + FRW, hd_data.f, family=binomial)
summary(fit1.6)
fit1.7 <- glm(HD~SBP + CIG, hd_data.f, family=binomial)
summary(fit1.7)
```
i. Which single variable would be the most important to add? Add it to your model, and call the new fit `fit2`.  
The most important is SEX. 

We will pick up the variable either with highest $|z|$ value, or smallest $p$ value. From all the two variable models we see that `SEX` will be the most important addition on top of the SBP. And here is the summary report.
```{r the most important addition, results='asis', comment="   "}
## How to control the summary(fit2) output to cut some junk?
## We could use packages: xtable or broom. 
library(xtable)
options(xtable.comment = FALSE)
fit2 <- glm(HD~SBP + SEX, hd_data.f, family=binomial)
xtable(fit2)
```
ii. Is the residual deviance of `fit2` always smaller than that of `fit1`? Why or why not?
Yes, this is because fit1 is a nested submodel of fit2 and more of the data can be explained by the fuller model (as indicated by a lower RSS as well). Therefore, the residual deviance (deviance for the proposed model) must be smaller for fit2 than for fit1. 

  
iii. Perform both the Wald test and the Likelihood ratio tests (Chi-Squared) to see if the added variable is significant at the .01 level.  What are the p-values from each test? Are they the same? 

```{r}
#Wald test
wald.pval <- summary(fit2)$coefficients[3,4]

#chi^2 test
chi.sq <- summary(fit2)$null.deviance - summary(fit2)$deviance
chi.pval <- pchisq(chi.sq, 2, lower.tail=FALSE)
```
The added SEX variable is signifcant at the 0.01 level. The p value for the Wald test is `r wald.pval` and the p value for the $\chi^2$ test is `r chi.pval`. They are similar but not the same.

### Part 1B -  Model building

Start with all variables. Our goal is to fit a well-fitting model, that is still small and easy to interpret (parsimonious).

i. Use backward selection method. Only keep variables whose coefficients are significantly different from 0 at .05 level. Kick out the variable with the largest p-value first, and then re-fit the model to see if there are other variables you want to kick out.
```{r}
fit.model <- glm(HD~., hd_data.f, family=binomial)
fit.model <- update(fit.model, .~. -DBP)
fit.model <- update(fit.model, .~. -FRW)
fit.model <- update(fit.model, .~. -CIG)
summary(fit.model)
```
ii. Use AIC as the criterion for model selection. Find a model with small AIC through exhaustive search. Does exhaustive search  guarantee that the p-values for all the remaining variables are less than .05? Is our final model here the same as the model from backwards elimination? 

The exhaustive search does not guarantee all variables will have p-values less than 0.05 since it is using AIC as its criterion for selecting the best model. Our final model is not the same as the one we have obtained through backwards selection. In fact, the exhaustive search model has CIG and FRW which were eliminated in the backwards elimination model.
```{r}
Xy <- model.matrix(HD ~.+0, hd_data.f) 
Xy <- data.frame(Xy, hd_data.f$HD)
fit.all <- bestglm(Xy, family = binomial, method = "exhaustive", IC="AIC", nvmax = 10)
summary(fit.all$BestModel)
```
iii. Use the model chosen from part ii. as the final model. Write a brief summary to describe important factors relating to Heart Diseases (i.e. the relationships between those variables in the model and heart disease). Give a definition of “important factors”. 
An important factor is a factor that is shown to have a relationship with blood disease from the data at a significance level of 0.05. The factors that are shown to increase the likelihood of heart disease are increasing age (aging), being male, higher systolic blood pressure (SBP), to a slightly less significant extent higher cholesterol levels and finally to an even lesser significant extent, increased cigarette consumption. 

If we define importance to be at the 0.01 signifance level, the previous factors remain the same but we would exclude increased cigarette consumption.

### Part 1C - Prediction
Liz is a patient with the following readings: `AGE=50, GENDER=FEMALE, SBP=110, DBP=80, CHOL=180, FRW=105, CIG=0`. What is the probability that she will have heart disease, according to our final model?
```{r}
liz <- hd_data.new
liz$AGE <- 50
liz$SBP <- 110
liz$DBP <- 80
liz$CHOL <- 180
liz$FRW <- 105
liz$CIG <- 0
liz$SEXMALE <- 0
liz.prob <- predict(fit.all$BestModel, liz, type="response")[1] # 
```

THe probability that Liz will have a heart disease is `r liz.prob`.

### Part 2 - Classification analysis

a. Display the ROC curve using `fit1`. Explain what ROC reports and how to use the graph. Specify the classifier such that the False Positive rate is less than .1 and the True Positive rate is as high as possible.

```{r}
fit1.roc <- roc(hd_data.f$HD, fit1$fitted, plot=T, col="blue")
allpoints <- coords(fit1.roc, "all", ret=c("threshold", "specificity"))
#get best threshold with specificity at 0.9 or greater
bestThreshold <- allpoints[,allpoints[2,]>=0.9][1,1]
```
The ROC curve graphs the True Positive Rate vs the False Positive Rate as we change the threshold for prediction in our classifier. Better classifiers have larger areas under the curve and have ROC curves that adhere as close as possible to the left border and upper border of the graph. The best threshold is predicting y=1 when P(y=1) > `r bestThreshold`.

b. Overlay two ROC curves: one from `fit1`, the other from `fit2`. Does one curve always contain the other curve? Is the AUC of one curve always larger than the AUC of the other one? Why or why not?

No, the ROC curve for fit2 does not entirely contain the ROC curve for fit1 because it's performance (specificity or sensitivity) is not better at all thresholds. However, fit2 performs better at many of the thresholds. This is most likely because fit2 contains a set of variables that are more relevant than fit1's that give it a better performance. Hence, the AUC for fit2's ROC curve is greater than fit1's AUC.

```{r}
fit2.roc <- roc(hd_data.f$HD, fit2$fitted, plot=T, col="blue")
two.rocs <-plot(1-fit1.roc$specificities, fit1.roc$sensitivities, col="red", pch=16, cex=.7, 
     xlab="False Positive", 
     ylab="Sensitivity")
points(1-fit2.roc$specificities, fit2.roc$sensitivities, col="blue", pch=16, cex=.6)
title("Blue line is for fit2, and red for fit1")

pROC::auc(fit1.roc)
pROC::auc(fit2.roc)
```

c. Estimate the Positive Prediction Values and Negative Prediction Values for `fit1` and `fit2` using .5 as a threshold. Which model is more desirable if we prioritize the Positive Prediction values?

```{r}
fit1.pred.67 <- rep("0", 1393)   # prediction step 1: set up all values to be "0"
fit1.pred.67[fit1$fitted > 1/2] <- "1"  # prediction step 2 to get a classifier
cm.1 <- table(fit1.pred.67, hd_data.f$HD)
positive.pred1 <- cm.1[2, 2] / (cm.1[2, 1] + cm.1[2, 2])
positive.pred1

negative.pred1 <- cm.1[1, 1] / (cm.1[1, 1] + cm.1[1, 2])
negative.pred1

fit2.pred.67 <- rep("0", 1393)   # prediction step 1: set up all values to be "0"
fit2.pred.67[fit2$fitted > 1/2] <- "1"  # prediction step 2 to get a classifier
cm.2 <- table(fit2.pred.67, hd_data.f$HD)
positive.pred2 <- cm.2[2, 2] / (cm.2[2, 1] + cm.2[2, 2])
positive.pred2

negative.pred2 <- cm.2[1, 1] / (cm.2[1, 1] + cm.2[1, 2])
negative.pred2
```

You would choose fit2 since `r positive.pred2` > `r positive.pred1`.


d. (Optional/extra credit) For `fit1`: overlay two curves,  but put the threshold over the probability function as the x-axis and positive prediction values and the negative prediction values as the y-axis.  Overlay the same plot for `fit2`. Which model would you choose if the set of positive and negative prediction values are the concerns? If you can find an R package to do so, you may use it directly.

```{r}
#shouldn't be too bad, maybe ROCR?
```
  
### Part 3 - Bayes Rule
Bayes rules with risk ratio $\frac{a_{10}}{a_{01}}=10$ or $\frac{a_{10}}{a_{01}}=1$. Use your final model obtained from 1 B) to build a class of linear classifiers.


a. Write down the linear boundary for the Bayes classifier if the risk ratio of $a_{10}/a_{01}=10$.
```{r}
summ2 <- summary(fit.all$BestModel)
prob1 <- 0.1/1.1
prob1.logit <- log(prob1/(1-prob1))
summ2$coefficients
summ2.intercept <- summ2$coefficients[1,1]
summ2.b1 <- summ2$coefficients[2,1]
summ2.b2 <- summ2$coefficients[3,1]
summ2.b3 <- summ2$coefficients[4,1]
summ2.b4 <- summ2$coefficients[5,1]
summ2.b5 <- summ2$coefficients[6,1]
summ2.b6 <- summ2$coefficients[7,1]
```
The boundary according to Bayes Rule is given by:
`r summ2.intercept` + `r summ2.b1`\*AGE + `r summ2.b2`\*SEXMALE + `r summ2.b3`\*SBP + `r summ2.b4`\*CHOL +  `r summ2.b5`\*FRW + `r summ2.b6`\*CIG + $\geq$ `r prob1.logit`

b. What is your estimated weighted misclassification error for this given risk ratio?
```{r}
fit1.pred.bayes <- rep("0", 1393)
fit1.pred.bayes[fit.all$BestModel$fitted > prob1] = "1" 
MCE.fit1 <- (sum(10*(fit1.pred.bayes[hd_data.f$HD == "1"] != "1")) + sum(fit1.pred.bayes[hd_data.f$HD == "0"] != "0"))/length(hd_data.f$HD)
MCE.fit1
```

The estimated weighted misclassification error is `r MCE.fit1`.

c. Recall Liz, our patient from part 1. How would you classify her under this classifier?
<!-- this answer depends on the correct calculation of liz.prob in part C --> 
We would classify her as not sick because `r liz.prob` $<$ `r prob1`.

Now, draw two estimated curves where x = posterior threshold, and y = misclassification errors, corresponding to the thresholding rule given in x-axis.

d. Use weighted misclassification error, and set $a_{10}/a_{01}=10$. How well does the Bayes rule classifier perform? 
```{r}
```
e. Use weighted misclassification error, and set $a_{10}/a_{01}=1$. How well does the Bayes rule classifier perform? 

## Problem 2

How well can we predict whether a bill will be passed by the legislature? 

Hundreds to thousands of bills are written each year in Pennsylvania. Some are long, others are short. Most of the bills do not even get to be voted on (“sent to the floor”). The chamber meets for 2-year sessions.  Bills that are not voted on before the end of the session (or which are voted on but lose the vote) are declared dead. Most bills die. In this study we examine about 8000 bills proposed since 2009, with the goal of building a classifier which has decent power to forecast which bills are likely to be passed. 

We have available some information about 8011 bills pertaining to legislation introduced into the Pennsylvania House of Representatives.  The goal is to predict which proposals will pass the House. Here is some information about the data:

The response is the variable called `status.` `Bill:passed` means that the bill passed the House; `governor:signed` means that the bill passed both chambers (including the House) and was enacted into law; `governor:received` means that the bill has passed both chambers and was placed before the governor for consideration.  All three of these statuses signify a success or a PASS (Meaning that the legislature passed the bill. This does not require it becoming law). All other outcomes are failures.

Here are the rest of the columns:

*	`Session` – in which legislative session was the bill introduced
*	`Sponsor_party` – the party of the legislator who sponsored the bill (every bill has a sponsor)
*	`Bill_id` – of the form HB-[bill number]-[session], e.g., `HB-2661-2013-2014` for the 2661st House Bill introduced in the 2013-2014 session.
*	`Num_cosponsors` – how many legislators cosponsored the bill
*	`Num_d_cosponsors` – how many Democrats cosponsored the bill
*	`Num_r_cosponsors` – how many Republicans cosponsored the bill
*	`Title_word_count` – how many words are in the bill’s title
*	`Originating_committee` – most bills are sent (“referred”) to a committee of jurisdiction (like the transportation committee, banking & insurance committee, agriculture & rural affairs committee) where they are discussed and amended.  The originating committee is the committee to which a bill is referred.
*	`Day_of_week_introduced` – on what day the bill was introduced in the House (1 is Monday)
*	`Num_amendments` – how many amendments the bill has
*	`Is_sponsor_in_leadership` – does the sponsor of the bill hold a position inside the House (such as speaker, majority leader, etc.)
*	`num_originating_committee_cosponsors` – how many cosponsors sit on the committee to which the bill is referred
*	`num_originating_committee_cosponsors_r` – how many Republican cosponsors sit on the committee to which the bill is referred
*	`num_originating_committee_cosponsors_d` - how many Democratic cosponsors sit on the committee to which the bill is referred

The data you can use to build the classifier is called `Bills.subset`. It contains 7011 records from the full data set. I took a random sample of 1000 bills from the 2013-2014 session as testing data set in order to test the quality of your classifier, it is called `Bills.subset.test.`

Your job is to choose a best set of classifiers such that

* The testing ROC curve pushes to the upper left corner the most, and has a competitive AUC value.
* Propose a reasonable loss function, and report the Bayes rule together with its weighted MIC. 
* You may also create some sensible variables based on the predictors or make other transformations to improve the performance of your classifier.

Here is what you need to report: 

1. Write a summary about the goal of the project. Give some background information. If desired, you may go online to find out more information.

The goal of the project is to develop and model useful for analysis and prediction. The first goal is to analyse i.e. determine what factors influence the passing of a bill. Second goal is to predict i.e., given data about a new bill, predict whether that bill would be passed or not.

2. Give a preliminary summary of the data. 
```{r}
bill <- read.csv('Bills.subset.csv', na.strings = c("", "N/A", "?"))
#dim(bill)
#na_count <- sapply(bill, function(y) sum(length(which(is.na(y)))))
#data.frame(na_count)
bill.train <- na.omit(bill)

#dim(bill.train)
bill.train['num_status'] <- "0" #Create categorical status
bill.train$num_status[bill.train$status == "bill:passed"] <- "1"
bill.train$num_status[bill.train$status == "governor:signed"] <- "1"
bill.train$num_status[bill.train$status == "governor:received"] <- "1"
bill.train$num_status <- as.factor(bill.train$num_status)

#Removing Bill ID as it wouldn't make much of a difference. Remove status as we've mapped the bill:signed, governor:signed and governor:received as SUCCESSFUL in num_status and num_cosponsors and num_originating_committee_cosponsors as these two variables are linearly dependent on the republican/democrat sponsors variables.
bill.train = bill.train[,-c(1, 4, 11, 13)]  

summary(bill.train)
```

```{r}
#summary
pairs(bill.train)
#TODO: add histograms
```

3. Based on the data available to you, you need to build a classifier. Provide the following information:
    *	The process of building your classifier
    *	Methods explored, and why you chose your final model
    *	Did you use a training and test set to build your classifier using the training data? If so, describe the process including information about the size of your training and test sets.
    
    *	What is the criterion being used to build your classifier?
    LASSO for dimensionality reduction and Ridge for stability
    Model selection methods that are computationally efficient
    Minimizing Mallow's Cp/AIC through model selection
    
    *	How do you estimate the quality of your classifier?
    ROC curves, maximizing AUC.
    Performance on test data set (accuracy, sensitivity, specificity)
    
```{r}
bill.xy <- model.matrix(num_status~.+0, bill.train)
bill.xy <- data.frame(bill.xy, bill.train$num_status)
```
    
```{r, eval=F}
#Exhaustive search, logreg
bill.exhaustive <- bestglm(bill.xy, IC="AIC", nvmax=20, family=binomial, method="exhaustive")
```

```{r, eval=F}
#Backwards selection, logreg
bill.back <- bestglm(bill.xy, IC="AIC", family=binomial, method="backward")
```

```{r, eval=F}
#Forwards selection, logreg
bill.back <- bestglm(bill.xy, IC="AIC", family=binomial, method="forward")
```

```{r}
bill.fit1 <- glm(num_status~., bill.train, family=binomial)
bill.fit2 <- update(bill.fit1, .~.-num_r_cosponsors)
bill.fit3 <- update(bill.fit2, .~.-num_d_cosponsors)
bill.fit4 <- update(bill.fit3, .~.-day.of.week.introduced)
bill.fit5 <- update(bill.fit4, .~.-num_originating_committee_cosponsors_r)
bill.fit6 <- update(bill.fit5, .~.-num_originating_committee_cosponsors_d)
bill.fit7 <- update(bill.fit6, .~.-is_sponsor_in_leadership)
Anova(bill.fit7)
```

```{r}
anova(bill.fit1,  bill.fit7,  test="Chisq")
```
We see from anova that the variables we have removed are indeed not significant at the 0.05 level. We therefore have a reasonable model. 

```{r}
#Load the test dataset and perform same precomputation
bill.test <- read.csv('Bills.subset.test.csv', na.strings = c("", "N/A", "?"))
#dim(bill.test)
#na_count <- sapply(bill.test, function(y) sum(length(which(is.na(y)))))
#data.frame(na_count)
bill.test <- na.omit(bill.test)

#dim(bill.test)
bill.test['num_status'] <- "0" #Create categorical status
bill.test$num_status[bill.test$status == "bill:passed"] <- "1"
bill.test$num_status[bill.test$status == "governor:signed"] <- "1"
bill.test$num_status[bill.test$status == "governor:received"] <- "1"
bill.test$num_status <- as.factor(bill.test$num_status)

bill.test = bill.test[,-c(1, 4, 11, 13)]  #Removing Bill ID as it wouldn't make much of a difference. Remove status and number sponsors 
summary(bill.test) 
#str(bill.test)
```
```{r}
fitted.test <- predict(bill.fit7, bill.test, type="response")
summary(fitted.test)
```

```{r}
backwards.glm <- rep("0", 999) # prediction step 1: set up all values to be "0"
backwards.glm[bill.fit7$fitted > 1/2] <- "1"  # prediction step 2 to get a classifier
cm.backwards <- table(backwards.glm, bill.train$num_status)
positive.pred1.backwards <- cm.backwards[2, 2] / (cm.backwards[2, 1] + cm.backwards[2, 2])
positive.pred1.backwards

negative.pred1.backwards <- cm.backwards[1,1] / (cm.backwards[1, 1] + cm.backwards[1, 2])
negative.pred1.backwards

cm.backwards
```

```{r}
bill.fit7.roc <- roc(bill.train$num_status, bill.fit7$fitted, plot=T, col="blue")
bill.fit7.auc <- pROC::auc(bill.fit7.roc)

allpoints.backward <- coords(bill.fit7.roc, "all", ret=c("threshold", "specificity"))
#get best threshold with specificity at 0.99 or greater
bestThreshold.backward <- allpoints.backward[,allpoints.backward[2,]>.99][1,1]
bestThreshold.backward
```

```{r}
models.lasso.cv <- cv.glmnet(data.matrix(bill.xy[,-c(43)]), y=as.factor(bill.xy$bill.train.num_status), nfolds = 10, alpha=0.9, family="binomial")
coef(models.lasso.cv, s = "lambda.min")

coef.min.sq <- coef(models.lasso.cv, s="lambda.1se") 
coef.min.sq <- coef.min.sq[which(coef.min.sq !=0),]
lasso.vars.sq <- rownames(as.matrix(coef.min.sq))

glm.input.sq <- as.formula(paste("num_status", "~", paste(lasso.vars.sq[-1], collapse = "+"))) # prepare for glm fomulae

#trying to get the LASSO model to fit into glm
bill.lasso.fit1 <- glm(glm.input.sq, bill.train, family=binomial)
```

* Exhaustive search, forward and backwards using bestglm hanged.
* Preformed backward model selection manually by eliminating the variables with highest p-value. Used Anova to determine the effect of categorical variable: all variables are significant at 0.001 level
* The positive prediction for this model is `r positive.pred1.backwards` and negative prediction is `r negative.pred1.backwards`. The AUC is `r bill.fit7.auc` which is quite good.

4. Suggestions you may have: what important features should have been collected which would have helped us to improve the quality of the classifiers.
A feature that would've potentially added more predictive power to our model are the actual text in the bills. If that were not possible then perhaps keywords to classify the jurisdiction or domain of the bill (eg. transportation, tax reform etc). Some interesting aspects to explore would've been to know whether the proposal came from a male or female legislator, time of day, and a subset of tweets that can give a reasonable overview of the public's state of mind or the political atmosphere/zeitgeist at the time (eg. Trump's tweets, what the popular topics on Twitter are, etc).

*Final notes*: The data is graciously lent from a friend. It is only meant for you to use in this class. All other uses are prohibited without permission. 

